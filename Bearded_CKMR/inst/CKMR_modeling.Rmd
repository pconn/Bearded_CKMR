---
title: "Bearded seal CKMR modeling"
author: "Paul Conn"
date: "12/2023"
output:
  pdf_document: default
  html_document: default
bibliography: master_bib.bib
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(digits = 2) #set to two decimal places
```


## Introduction

In this document, we describe CKMR models fitted to bearded seal kinship data.  
The theory and equations behind these models is provided elsewhere, so the primary 
focus here is to ensure repeatability of our analysis.  However, we do provide
some information on population dynamics equations since this is key knowledge for
how initial values were set.


### Bearded seal population dynamics model

Underpinning all of our CKMR analyses is an age-structured population dynamics model composed
of annual survival probabilities and fecundity values.  We will assume a postbreeding census, in which case the number of new recruits each year is given by

$$  N_{t,0}^F = N_{t,0}^M = 0.5 \sum_a N_{t-1,a}^F \phi_a f_{t-1,a},$$
where $N_{t,a}^F$ gives the number of age $a$ females (males use the superscritp 'M') alive at time $t$, $\phi_a$ is
annual survival probability for age $a$ seals, and $f_a$ is female fecundity-at-age (# of pups produced).  Note that we assume a 50/50 sex ratio of pups at birth, which is a reasonable assumption given data collected on sex ratios of pups in the field [@Fedoseev2000].  Later age classes are propagated forward 
as a function of age specific survival; i.e., $N_{t,a}^F = N_{t,a}^M = N_{t-1,a-1}\phi_{a-1}$ for $a>0, t>0$).  In the following CKMR models, we only estimate one abundance paramameter: $N_{0,0}^F$ (where $N_{0,0}^M$ is set equal to $N_{0,0}^F$).  The remaining cohort abundances in year 0 are set equal to relevant stable stage proportions from the associated matrix population model [@Caswell2001], and subsequent years abundance are then completely determined.

### Priors on life history parameters

Close-kin mark-recapture models only provide limited information on life history parameters.  For instance, half-siblings provide information on adult survival (provided that aging has reasonable precision), while parent-offspring pairs provide information on fecundity-at-age.  However, bearded seal sample sizes are quite small, so we provided informative priors on survival and fixed fecundity-at-age.

For survival-at-age, we based informative priors on a hierarchical
meta-analysis of phocid seal mortality [@TrukhanovaEtAl2018].  This meta-analysis used a reduced additive Weibull distrubtion (RAW) [@ChoquetEtAl2011] to model mortality as a function of age for different phocid seal species and populations.  The RAW model is characterized by a "bathtub" shape for mortality (i.e, high mortality at young ages, low mortality for young adults, and increasing mortality for the oldest individuals).  According to this framework, age-specific annual survival at age $a$ ($S_a$) is given by 

$$ S_a = \exp(-(\eta_1 a)^{\eta_2} - (\eta_1 a)^{1/\eta_2} - \eta_3 a), $$
where $\eta_1$, $\eta_2$, and $\eta_3$ are estimated parameters. The values of these
parameters from hierarchical analysis [@TrukhanovaEtAl2018] were $\eta_1 = 0.055$, $\eta_2 = 2.80$, and $\eta_3=0.076$ [@ConnEtAl2020].  

We set fecundity-at-age values equal to schedules reported by [@ConnTrukhanova2022], who fitted generalized additive models to data from specimens collected in the Bering and Chukchi Seas.  These data represented the proportion of age $a$ females who had given birth or were pregnant in the spring.  Sample collections were derived from Native Alaskan subsistence harvests which are monitored by the Alaska Department of Fish and Game, as well as records reported from Russia in the 1980s [@Fedoseev2000].  

Although not needed explicitly for population modeling, CKMR paternal kinship probabilities (including half-siblings that are paternally related) rely on relative paternal reproductive output as a function of age.  We based these calculations in part on male maturity schedules reported by [@ConnTrukhanova2022], which were derived from collections from the Bering and Okhotsk seas [@Tikhomirov1966].  Survival-, fecundity, and maturity-at-age ($m_a$) are plotted below.

```{r at_age}
  Maturity = read.csv("c:/users/paul.conn/git/ckmr/Bearded_ADFG/Maturity.csv")
  Survival = read.csv("c:/users/paul.conn/git/ckmr/Bearded_ADFG/Survival_ests.csv")
  Reprod = read.csv("c:/users/paul.conn/git/ckmr/Bearded_ADFG/Reproduction_table.csv")
  
  Male_mat <- rep(1,40)
  Fem_fec <- rep(0.938,40)
  Male_mat[1:10]=c(0,Maturity$Bearded.male)
  Fem_fec[1:10]=c(0,Reprod$bearded)
  Plot_df = data.frame("Vital_rate"=rep(c("Fem_fec","Male_mat","Survival"),each=40),
                      "Value"=c(Fem_fec,Male_mat,Survival$bearded),
                      "Age"= rep(c(0:39),3))
  library(ggplot2)
  vital_plot = ggplot(Plot_df)+geom_line(linewidth=0.8,aes(x=Age,y=Value,colour=Vital_rate,linetype=Vital_rate))+theme_bw()+theme(legend.key.width = unit(2, "line"))+labs(color = "Vital rate",linetype="Vital rate")+
    scale_color_manual(values=c("purple","blue","darkorange"),labels = c("Female fecundity", "Male maturity","Survival"))+scale_linetype_manual(values=c("dotted","dashed","solid"),labels = c("Female fecundity", "Male maturity","Survival"))
  vital_plot
  png('vital_rate_prior_plot.png')
    vital_plot
  dev.off()
```

One interesting thing to note about using fixed values of fecundity- and survival-at-age is that the corresponding Leslie matrix implies a very specific population trend, and owing to measurement error in estimation of both sets of vital rates it is possible for the implied
finite rate of poulation increase ($\lambda$) to indicate increasing of decreasing populations.  Let's see what $\lambda$ value these vital rates would imply, should an equilibrium age structure be reached:

```{r Leslie}
# set up leslie matrices - via an array (4 matrices, one for each species)
A = matrix(0,40,40)  
for(iage in 1:39){
  A[iage+1,iage]=Survival[iage,"bearded"]  #assume post-breeding census
}

#reproduction; nb: adults have to survive to next spring to reproduce
# nb: Leslie matrices are "female only" and assume a 50/50 sex ratio at birth
A[1,]=0.5*Fem_fec*Survival$bearded  

eigen(A)$values[1]
```

So, it would appear that this combination of fecundity-at-age and survival-at-age 
is expected to result in about a 4% annual increase in abundance.  This is clearly undesirable, because we do not want to presuppose such an increase before we start
analyzing CKMR data.  There are potentially several fixes to this.  First, since survival-at-age is presumably much more uncertain than fecundity-at-age (the former having been produced from a meta-analysis rather than an actual field study), we might consider manipulating survival-at-age values until $\lambda=1.0$.  This was the approach taken by [@ConnEtAl2020] when analyzing simulated data that were patterned after bearded seal life history parameters.  Alternatively, we could let a CKMR model attempt to estimate updated RAW parameter values, subject to a constraint enforcing a specific value of $\lambda$ (e.g., 1.0). Given that our kinship data seem like they're too sparse to permit robust inference about population trend, this is the approach we will start off with in our first CKMR analyses with bearded seal data.

### Imposing a PLOD threshold

So far, we have been assuming that we have been able to fully discriminate HSP/GGP pairs from more distant
kin pairs (e.g., half-aunt-niece, etc.).  In truth, it is difficult to discriminate between the two at lower PLOD scores, and it is often worth imposing a lower threshold for PLOD scores to eliminate possible lower order kin.  In this case, we can try to account for the HSP/GGPs that are under our assigned lower threshold by doing some creative modeling.  The following is an attempt to show our conundrum graphically; here, the red line depicts a hypothetical expected frequency of PLOD scores among unrelated pairs (with a bump centered at zero), and the blue line depicts the same for HSGGPs (here centered at 100).  The issue is at scores of e.g. 50-70.  These matches could conceivably be of either type.

```{r PLODogram}
  X = c(-50:150)
  Y_no = 500*dnorm(X,0,20)
  Y_sib = 100*dnorm(X,100,20)
  Plot_df = data.frame("PLOD_value"=rep(X,2),"Exp_count"=c(Y_no,Y_sib),Type=c(rep("Distant",length(X)),rep("HSGGP",length(X))))
  library(ggplot2)
  ggplot(Plot_df)+geom_line(aes(x=PLOD_value,y=Exp_count,group=Type,color=Type))
```

One thing we might do then is to impose a threshold (let's say PLOD_value=70) that essentially makes the probability of 
a false positive HSGGP negligible.  If we knew the parameters of the blue curve and are willing to assume normality, we could then calculate the probability of
detecting and including an HSGGP in our modeling procedure as e.g.

$$
  d=\int_{x=70}^{\infty} f(x;\mu,\sigma^2) dx
$$
where $f(x;\mu,\sigma^2)$ is a Gaussian probability density function with mean $\mu$ and variance $\sigma^2$. To include
this quantity in estimation, we can simply replace $p_{ij2}$ with $p_{ij2}d$ everywhere it occurs in the CKMR pseudo-likelihood.

Let's take a look at some possible PLOD thresholds with our bearded seal dataset.  We'll start by plotting a histogram of potential HSP scores

```{r,plod_hists,tidy='styler',cache=T}
load('c:/users/paul.conn/git/ckmr/bearded_adfg/HSP_plod_info.RData')

hist(HSP_PLOD_info$HSP_PLODs,breaks=20,xlab="PLOD score",main="Potential HSP plod scores")
abline(v=HSP_PLOD_info$HSPmean,col="red")

png("HSP_plod_bearded.png")
  hist(HSP_PLOD_info$HSP_PLODs,breaks=20,xlab="PLOD score",main="Potential HSP plod scores")
  abline(v=HSP_PLOD_info$HSPmean,col="red")
dev.off()
  
```

Here, the red line shows the theoretical place (based on Hardy-Weinberg) where the peak of PLOD scores should be for HSPs (and GGPs!); the peak closer
to zero is for related kin, but lesser so than HSPs (e.g., half-aunt/niece, etc.).  In order to set PLOD thresholds we need to know something about the variance of the HSP peak.  Because the left hand side is potentially contaminated by weak kin pairs, the only ``safe" thing to do is to use the right hand side of the distribution
to estimate variance.  Let's fit a half-normal distribution to these scores using maximum likelihood.  We'll use
this fitted model to predict the probability of a HSP occurring with PLOD scores below certain thresholds (specifically, 30, 40, and 50).

```{r,plod_est,tidy='styler',cache=T}

Upper_sample = HSP_PLOD_info$HSP_PLODs[which(HSP_PLOD_info$HSP_PLODs>HSP_PLOD_info$HSPmean)]
HalfN_sample = Upper_sample-HSP_PLOD_info$HSPmean

ML_fun <- function(sd_log,Data){
  sd = exp(sd_log)
  -sum(2*dnorm(Data,0,sd,log=T))
}

Estim = nlminb(log(10),ML_fun,Data=HalfN_sample)
sd_est = exp(Estim$par)

pnorm(30,HSP_PLOD_info$HSPmean,sd_est)

pnorm(40,HSP_PLOD_info$HSPmean,sd_est)

pnorm(50,HSP_PLOD_info$HSPmean,sd_est)

```

This little experiment is something that should be conducted in all CKMR experiments using half-siblings.  However, it also demonstrates the very real complications that can happen with small datasets! In particular, there is a very subjective "gap" around 25 that is tempting to take as a cutoff; however, our analysis suggests that the
PLOD cutoff could potentially be much higher (e.g., 40-50).  There are some other details that we can look at to 
justify a decision.  In particular, half-aunts/nieces, etc. will typically have larger age differences with a mode near one generation time.  In the bearded seal case, potential HSPs with PLOD scores above 25 tend to have lower age differences than matches with lower PLOD scores; however, this isn't definitive.  Our view is that we were probably unlucky (in the sense that we had low sample size), and the observed variance to the right hand side of the red line is lower than we would normally observe in a sample of this size.  However, it's hard to say for sure, and we'll be somewhat conservative and use a cutoff of 40 as a ``base case" in subsequent model runs.  Let's now limit our HSP matches to those that have a PLOD threshold of 40.  

```{r,limit_plod,tidy='styler',cache=T}
load('CKMR_sample_data.RData')
p_plod = 1-pnorm(40,HSP_PLOD_info$HSPmean,sd_est)  #to account for false negative HSP/GGPs in CKMR models 
matches_PHS = CKMR_certain_age$matches_PHS[which(CKMR_certain_age$matches_PHS$PLOD>40),]
matches_MHS = CKMR_certain_age$matches_MHS[which(CKMR_certain_age$matches_MHS$PLOD>40),]
```

This reduces the number of HSPs to `r nrow(matches_PHS)+nrow(matches_MHS)` from the original 25.

### CKMR modeling

Our CKMR models all assume ages are certain and inference is based on
maximum marginal pseudo-likelihood inference, with an observation model based on
a product Bernoulli likelihood reflecting a large number of pairwise kinship comparisons [@BravingtonEtAl2016].  Specifically, we base inference on the joint pseudo-likelihood

$$
  L = L_{pop} L_{hsp/ggp} f(\boldsymbol{\eta}) \Lambda_\lambda ,
$$

where $L_{pop}$ is a product Bernoulli likelihood for parent-offspring pairs, $L_{hsp/ggp}$ is a product Bernoulli likelihood for half siblings and grandparent-grandchild pairs (modeled as a mixture), $f(\eta)$ are penalties on RAW survival parameters if they deviate from their prior mean, and $\Lambda_\lambda$ is a penalty for population trend that is $>0$ when $\lambda \ne \lambda_0$ (where $\lambda_0$ is pre-specified by the analyst).  These likelihoods are described elsewhere, so we will now turn to model fitting.

All CKMR models were programmed in Template Model Builder (TMB; [@KristensenEtAl2016]). Conditioning on observed kinship observations, the joint negative log likelihood (i.e., $-\log(L)$) was minimized as a function of $N_{0,0}^F$ and $\boldsymbol{\eta}$ parameters using the "nlminb" function in R [@RTeam2017].  Some computational efficiency is gained by noting that many of the pairwise kinship probabilities are the same (e.g., for individuals of the same sex and with the same birth years and year of death) and grouping pairs this way. Modeling these sufficient statistics prevents us from having to do $n^2-n$ separate comparison computations every time the likelihood is evaluated. The next block of code is concerned with computing the number of comparisons and matches for POPs and HS-GGPs.  Note that we go back one generation time to start the model to allow us to model relative reproductive output of parents of half-siblings that are encountered near the beginning of the study.

```{r,suffstat,tidy='styler',cache=T,include=FALSE}
  n_ages = 40
  min_yr = min(CKMR_certain_age$Samples$YEAR)
  max_yr = max(CKMR_certain_age$Samples$YEAR)
  n_yrs_data = max_yr-min_yr+1
  n_yrs = n_yrs_data+n_ages  #number of years of data + 1 generation time
  n_seals = nrow(CKMR_certain_age$Samples)
  
  #sufficient statistics for binomial model instead of bernoulli - number of trials, number of successes
  #observed birth years can only be one generation back so we'll start these off in year 41
  n_comp_PPO_bidibj=n_comp_MPO_bidibj=n_match_PPO_bidibj=n_match_MPO_bidibj=array(0,dim=c(n_yrs,n_yrs_data,n_yrs))

  #determine birth year, death year relative to comparison, match data structures 
  BY = CKMR_certain_age$Samples$YEAR-min_yr+n_ages+1-CKMR_certain_age$Samples$AgeCombined
  DY = CKMR_certain_age$Samples$YEAR-min_yr+1
  DY2 = CKMR_certain_age$Samples$YEAR-min_yr+n_ages+1 #for making comparisons with BY
  Sex  = CKMR_certain_age$Samples$SexDArT
  
  #Now, each bearded seal pairwise comparison will contribute one to # of comparisons matrices; note that comparisons
  #aren't differentiated by sex for HS, but are for PO because in the latter case we know what sex the potential parent was
  for(iseal in 1:(n_seals-1)){
    for(jseal in (iseal+1):n_seals){  #prevent double counting
      if(BY[iseal]<BY[jseal]){
        if(DY2[iseal]>=(BY[jseal]-1) & Sex[iseal]=="M")
          n_comp_PPO_bidibj[BY[iseal],DY[iseal],BY[jseal]]=n_comp_PPO_bidibj[BY[iseal],DY[iseal],BY[jseal]]+1  ###no comprison needed for potential father that die before offspring conceived
        if(DY2[iseal]>=(BY[jseal]) & Sex[iseal]=="F")
          n_comp_MPO_bidibj[BY[iseal],DY[iseal],BY[jseal]]=n_comp_MPO_bidibj[BY[iseal],DY[iseal],BY[jseal]]+1  ###no 
      } 
      if(BY[iseal]>BY[jseal]){
        if(DY2[jseal]>=(BY[iseal]-1) & Sex[jseal]=="M")
          n_comp_PPO_bidibj[BY[jseal],DY[jseal],BY[iseal]]=n_comp_PPO_bidibj[BY[jseal],DY[jseal],BY[iseal]]+1  ###no comprison needed for potential father that die before offspring conceived
        if(DY2[jseal]>=(BY[iseal]) & Sex[jseal]=="F")
          n_comp_MPO_bidibj[BY[jseal],DY[jseal],BY[iseal]]=n_comp_MPO_bidibj[BY[jseal],DY[jseal],BY[iseal]]+1  ###no 
      }
    }
  }
  
  #Format matches matrices
  #POPs
  for(imatch in 1:nrow(CKMR_certain_age$matches_POP)){
    if(CKMR_certain_age$matches_POP$mtDNA[imatch]=="P"){
      if(BY[CKMR_certain_age$matches_POP[imatch,"i"]]<BY[CKMR_certain_age$matches_POP[imatch,"j"]])
        n_match_PPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"i"]],DY[CKMR_certain_age$matches_POP[imatch,"i"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"j"]]]=
          n_match_PPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"i"]],DY[CKMR_certain_age$matches_POP[imatch,"i"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"j"]]]+1
      else n_match_PPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"j"]],DY[CKMR_certain_age$matches_POP[imatch,"j"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"i"]]]=
          n_match_PPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"j"]],DY[CKMR_certain_age$matches_POP[imatch,"j"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"i"]]]+1
    }
    if(CKMR_certain_age$matches_POP$mtDNA[imatch]=="M"){
      if(BY[CKMR_certain_age$matches_POP[imatch,"i"]]<BY[CKMR_certain_age$matches_POP[imatch,"j"]])
        n_match_MPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"i"]],DY[CKMR_certain_age$matches_POP[imatch,"i"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"j"]]]=
          n_match_MPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"i"]],DY[CKMR_certain_age$matches_POP[imatch,"i"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"j"]]]+1
      else n_match_MPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"j"]],DY[CKMR_certain_age$matches_POP[imatch,"j"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"i"]]]=
          n_match_MPO_bidibj[BY[CKMR_certain_age$matches_POP[imatch,"j"]],DY[CKMR_certain_age$matches_POP[imatch,"j"]],
                           BY[CKMR_certain_age$matches_POP[imatch,"i"]]]+1
    }
  }
  
  #HSP-GGPs
n_comp_HSGGP_sibidibj = array(0,dim=c(2,n_yrs,n_yrs_data,n_yrs))
n_match_HSGGP_sibidibjmij = array(0,dim=c(2,n_yrs,n_yrs_data,n_yrs,2))

for(iseal in 1:(n_seals-1)){
  for(jseal in (iseal+1):n_seals){  #prevent double counting
    if(BY[iseal]<=BY[jseal])
      n_comp_HSGGP_sibidibj[(Sex[iseal]=="M")+1,BY[iseal],DY[iseal],BY[jseal]]=
        n_comp_HSGGP_sibidibj[(Sex[iseal]=="M")+1,BY[iseal],DY[iseal],BY[jseal]]+1
    if(BY[iseal]>BY[jseal])n_comp_HSGGP_sibidibj[(Sex[iseal]=="M")+1,BY[jseal],DY[jseal],BY[iseal]]=
        n_comp_HSGGP_sibidibj[(Sex[iseal]=="M")+1,BY[jseal],DY[jseal],BY[iseal]]+1
    # we'll need to make probs 0 for MHSPs since only one pup/yr; restrictions will need to 
    # be made on ages in TMB to prevent GGP comparisons when death of grandparent occurs in inadmissable range
  }
}

#matches
#HSPs
for(imatch in 1:nrow(matches_PHS)){
  if(BY[matches_PHS[imatch,"i"]]<=BY[matches_PHS[imatch,"j"]])
    n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$i[imatch]]=="M")+1,BY[matches_PHS$i[imatch]],DY[matches_PHS$i[imatch]],BY[matches_PHS$j[imatch]],1]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$i[imatch]]=="M")+1,BY[matches_PHS$i[imatch]],DY[matches_PHS$i[imatch]],BY[matches_PHS$j[imatch]],1]+1
  else
    n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$j[imatch]]=="M")+1,BY[matches_PHS$j[imatch]],DY[matches_PHS$j[imatch]],BY[matches_PHS$i[imatch]],1]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$j[imatch]]=="M")+1,BY[matches_PHS$j[imatch]],DY[matches_PHS$j[imatch]],BY[matches_PHS$i[imatch]],1]+1}

for(imatch in 1:nrow(matches_MHS)){
  if(BY[matches_MHS[imatch,"i"]]<=BY[matches_MHS[imatch,"j"]])
    n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$i[imatch]]=="M")+1,BY[matches_MHS$i[imatch]],DY[matches_MHS$i[imatch]],BY[matches_MHS$j[imatch]],2]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$i[imatch]]=="M")+1,BY[matches_MHS$i[imatch]],DY[matches_MHS$i[imatch]],BY[matches_MHS$j[imatch]],2]+1
  else
    n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$j[imatch]]=="M")+1,BY[matches_MHS$j[imatch]],DY[matches_MHS$j[imatch]],BY[matches_MHS$i[imatch]],2]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$j[imatch]]=="M")+1,BY[matches_MHS$j[imatch]],DY[matches_MHS$j[imatch]],BY[matches_MHS$i[imatch]],2]+1}

n_match_HSGGP_40 = n_match_HSGGP_sibidibjmij

```

Now, let's actually use these sufficient statistics to fit our CKMR model:


```{r,run_GGP,tidy='styler',cache=T,include=FALSE}
Data =  list("n_yrs"=n_yrs,"n_yrs_data"=n_yrs_data,"n_seals"=n_seals,"n_ages"=n_ages,
            "Male_mat"=Male_mat,"Fem_fec"=Fem_fec,"A"=A,"n_match_HSGGP_sibidibjmij"=n_match_HSGGP_sibidibjmij,
            "n_comp_HSGGP_sibidibj"=n_comp_HSGGP_sibidibj,
            "n_match_MPO_bidibj"=n_match_MPO_bidibj,"n_comp_MPO_bidibj"=n_comp_MPO_bidibj,
            "n_match_PPO_bidibj"=n_match_PPO_bidibj,"n_comp_PPO_bidibj"=n_comp_PPO_bidibj,
            mu_log_eta1=log(0.055),mu_log_eta2=log(2.8),mu_log_eta3=log(0.076),
            sd_log_eta1=0.07*abs(log(0.055)),sd_log_eta2=0.2*abs(log(2.8)),sd_log_eta3=abs(0.08*log(0.076)),
            lambda_expect=1.0,min_repro_fem =3,min_repro_male=5,p_plod=p_plod)  #SD log multipliers set to achieve approx CV of 0.2 on real scale

  Params = list("n0_log"=log(20000),"log_eta1"=log(0.055),"log_eta2"=log(2.80),"log_eta3"=log(0.076)) #intial param values
  
  Map = list()  #specify fixed parameter values
  Random=NULL
  
library(TMB)
TmbFile_GGP = "c:/users/paul.conn/git/CKMR/bearded_ADFG/bearded_CKMR/src/certain_ages_GGP_plod.cpp"
compile(TmbFile_GGP )
TmbExec_GGP="c:/users/paul.conn/git/CKMR/bearded_ADFG/bearded_CKMR/src/certain_ages_GGP_plod"
dyn.load(dynlib(TmbExec_GGP))


Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod")

Obj$fn( Obj$par )
Report = Obj$report()


#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report=Report_NoHet40 = Obj$report()
SD_report=sdreport(Obj)
N_est_TMB = SD_report$value[which(names(SD_report$value)=="N")]

```
The time to fit the combined GGP-HSP model was (up to `r End_time-Start_time`).  The
abundance estimate is `r Report$N[1]`.  The expected number of grandparent-grandchild pairs given our data
and model fit is `r sum(Data$n_comp_HSGGP_sibidibj*Report$GGP_table[,,,,1]+Data$n_comp_HSGGP_sibidibj*Report$GGP_table[,,,,2])`.
  
Let's take a look at the relative probabilities of individual seals being HSPs vs GGPs.  

```{r GGPvsHSP,tidy='styler',cache=T}
  HSPs = which(Data$n_match_HSGGP_sibidibjmij==1,arr.ind=TRUE) 
  HSPs = data.frame(HSPs)
  colnames(HSPs) = c("Older_sex","birth_i","death_i","birth_j","mito")
  HSPs$Rel_prob_HSP = HSPs$prob_GGP = HSPs$prob_HSP = 0
  for(i in 1:nrow(HSPs)){
    GGP_prob = Report$GGP_table[HSPs[i,1],HSPs[i,2],HSPs[i,3],HSPs[i,4],HSPs[i,5]]
    HSPs$prob_GGP[i] = GGP_prob
    if(HSPs$mito[i]==1){   #use PHSP table
      HSPs$Rel_prob_HSP[i] = Report$PHS_table[HSPs[i,2],HSPs[i,4]]/(Report$PHS_table[HSPs[i,2],HSPs[i,4]]+GGP_prob)
      HSPs$prob_HSP[i] = Report$PHS_table[HSPs[i,2],HSPs[i,4]]
    }
    else{ 
      HSPs$prob_HSP[i] = Report$MHS_table[HSPs[i,2],HSPs[i,4]]
      HSPs$Rel_prob_HSP[i] = Report$MHS_table[HSPs[i,2],HSPs[i,4]]/(Report$MHS_table[HSPs[i,2],HSPs[i,4]]+GGP_prob)
    }
  }
  print(HSPs)
  
```  
  
It looks like there are `r sum(HSPs$Rel_prob_HSP<1)` seals that have potential to be GGPs, though the relative probabilities
still favor these being HSPs (the first row has the highest probability of being a GGP, at `r 1-HSPs[1,"Rel_prob_HSP"]`).
  
  
Out of curiosity, we might examine what would happen if we fit a CKMR model which didn't allow for the possibility of GGPs.  Let's do this.

```{r noGGP,tidy='styler',cache=T}
library(TMB)
TmbFile_noGGP = "c:/users/paul.conn/git/CKMR/bearded_ADFG/bearded_CKMR/src/certain_ages_plod.cpp"
compile(TmbFile_noGGP )
TmbExec_noGGP="c:/users/paul.conn/git/CKMR/bearded_ADFG/bearded_CKMR/src/certain_ages_plod"
dyn.load(dynlib(TmbExec_noGGP))

Data_noGGP =  list("n_yrs"=n_yrs,"n_yrs_data"=n_yrs_data,"n_seals"=n_seals,"n_ages"=n_ages,
            "Male_mat"=Male_mat,"Fem_fec"=Fem_fec,"A"=A,
            "n_match_MPO_bidibj"=n_match_MPO_bidibj,"n_comp_MPO_bidibj"=n_comp_MPO_bidibj,
            "n_match_PPO_bidibj"=n_match_PPO_bidibj,"n_comp_PPO_bidibj"=n_comp_PPO_bidibj,
            mu_log_eta1=log(0.055),mu_log_eta2=log(2.8),mu_log_eta3=log(0.076),
            sd_log_eta1=0.07*abs(log(0.055)),sd_log_eta2=0.2*abs(log(2.8)),sd_log_eta3=abs(0.08*log(0.076)),
            lambda_expect=1.0,min_repro_fem =3,min_repro_male=5,p_plod=p_plod)  #SD log multipliers set to 

Data_noGGP$n_match_MHS_bibj = apply(Data$n_match_HSGGP_sibidibjmij[,,,,2],c(2,4),'sum') 
Data_noGGP$n_match_PHS_bibj = apply(Data$n_match_HSGGP_sibidibjmij[,,,,1],c(2,4),'sum')
Data_noGGP$n_comp_HS_bibj = apply(Data$n_comp_HSGGP,c(2,4),'sum') 

Obj <- MakeADFun(data=Data_noGGP, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_plod")

Obj$fn( Obj$par )
Report = Obj$report()


#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report=Report_NoGGP = Obj$report()
SD_report_NoGGP=sdreport(Obj)
N_est_NoGGP = SD_report_NoGGP$value[which(names(SD_report_NoGGP$value)=="N")]
```

In this case, abundance is estimated as `r N_est_NoGGP[1]` with a CV of `r SD_report_NoGGP$sd[which(names(SD_report_NoGGP$value)=="N")][1]/N_est_NoGGP[1]`

### Male heterogeneity

Looking at the data for the PLOD cutoff of 40, there are a total of `r sum(Data$n_match_HSGGP_sibidibjmij[,,,,1])` HSP/GGPs that don't share mtDNA, and `r sum(Data$n_match_HSGGP_sibidibjmij[,,,,2])` that do share mtDNA.  If we look at these records, it looks like there are 4 that have a chance of being GGPs, but in each case they are more likely to be HSPs.  If we assume that they are all HSPs, and also assume that we are equally likely to detect maternal and paternal HSPs, the probability of observing so few paternal HSPs is `r pbinom(7,22,0.5)`.  This is could have happened by random chance, or it could be a problem with our model.  Conditional on the observed data and parameter estimates of our CKMR model, the expected number of MHSPs and PHSPs are `r sum(Report$expected_MHSP)` and `r sum(Report$expected_PHSP)`, respectively.  A $\chi^2$ test with expected and observed numbers of HSPs by sex generates a p-value of 0.17 ($\chi^2 = 1.9, df=1$).

So why do male HSPs outnumber female HSPs by such a large margin?  One explanation is heterogeneity in male reproductive success (e.g., if older or higher quality males are able to breed with more females than younger or lower quality males).  For instance, male bearded seals are known
to maintain underwater territories during the breeding season, and it may be the case that there may be some competition for mates.  Also, male sexual maturity was based on physical characteristics (e.g., presence of semen in testicles of dead specimens), and it may be the case that there is a delay before physically mature males become successful breeders.  

In order to account for this possibility, we fit an alternative model where we assumed the number of male  breeders is an unknown fraction ($\pi$) of the total number of reproductively mature males.  Specifically, we set $N_{t,a}^M = 0.5 N_{t,a} \pi$ everywhere that male abundance appears in previous calculations. 


```{r,male_het,tidy='styler',cache=T,include=FALSE}
Params$male_scale_logit = 2.0 

TmbFile_het = "c:/users/paul.conn/git/CKMR/bearded_ADFG/bearded_CKMR/src/certain_ages_GGP_plod_het.cpp"
compile(TmbFile_het )
TmbExec_het="c:/users/paul.conn/git/CKMR/bearded_ADFG/bearded_CKMR/src/certain_ages_GGP_plod_het"
dyn.load(dynlib(TmbExec_het))


Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_het=Obj$report()
SD_report_het=sdreport(Obj)
N_est_TMB_het = SD_report_het$value[which(names(SD_report_het$value)=="N")]
SD_N_het = SD_report_het$sd[which(names(SD_report_het$value)=="N")]


```

After running this model, we have $\hat{\pi}=$ `r plogis(Report_het$male_scale_logit)`, suggesting that only a relatively small fraction of 
reproductively mature males are successfully producing offspring each year. As expected, this leads to an increase in estimated abundance, which is now at $\hat{N}=$ `r N_est_TMB_het[1]`.  This model is supported by AIC, with $\delta \text{AIC}=$ `r 2*(Report_het$logl1-Report$logl1)-2` over the model without heterogeneity.  Predictions of the number of maternal and paternal HSPs are now `r sum(Report_het$expected_MHSP)` and `r sum(Report_het$expected_PHSP)`, much closer to the observed values of 7 and 15.

Although we will keep this heterogeneity model as our ``preferred" model, we wanted to see how much of a shift in the male maturity curve would be needed to produce a similar result.  After experimenting with a variety  the male maturity curve by a number  could accomplish the same thing, we found that male sexual maturity would need to be delayed by 8 years to result in $\hat{\pi}=1.0$:

```{r,male_mat,tidy='styler',cache=T,include=FALSE}
Data$Male_mat[14:15]=c(0.5,0.66)
Data$Male_mat[6:13]=0

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_mat=Obj$report()
SD_report_mat=sdreport(Obj)
N_est_TMB_mat = SD_report_mat$value[which(names(SD_report_mat$value)=="N")]
SD_N_mat = SD_report_mat$sd[which(names(SD_report_mat$value)=="N")]

Data$Male_mat = Male_mat #set back to original for future runs
```

### Alternative trend scenarios

Another possible source of structural uncertainty is with our assumption that abundance is constant over time. Let's look and see what happens
when we investigate four alternative trend scenarios, including a constant 2\% annual rate of increase/increase and a 4\% rate of increase/decrease over time.  In practice, it would be impossible to sustain a constant increase or decrease over a long period, but it will be instructive to see what alternative trends do to the overall scale of our estimate.  Let's do this with the heterogeneity model.

```{r,run_trend,tidy='styler',cache=T,include=FALSE}
Data$lambda_expect = 1.02

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_lambda_102=Obj$report()
SD_report_lambda_102=sdreport(Obj)
N_est_TMB_lambda_102 = SD_report_lambda_102$value[which(names(SD_report_lambda_102$value)=="N")]
SD_N_lambda_inc102 = SD_report_lambda_102$sd[which(names(SD_report_lambda_102$value)=="N")]

Data$lambda_expect = 0.98

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_lambda_98=Obj$report()
SD_report_lambda_98=sdreport(Obj)
N_est_TMB_lambda_98 = SD_report_lambda_98$value[which(names(SD_report_lambda_98$value)=="N")]
SD_N_lambda_98 = SD_report_lambda_98$sd[which(names(SD_report_lambda_98$value)=="N")]

Data$lambda_expect = 1.04

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_lambda_104=Obj$report()
SD_report_lambda_104=sdreport(Obj)
N_est_TMB_lambda_104 = SD_report_lambda_104$value[which(names(SD_report_lambda_104$value)=="N")]
SD_N_lambda_104 = SD_report_lambda_104$sd[which(names(SD_report_lambda_104$value)=="N")]

Data$lambda_expect = 0.96

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_lambda_96=Obj$report()
SD_report_lambda_96=sdreport(Obj)
N_est_TMB_lambda_96 = SD_report_lambda_96$value[which(names(SD_report_lambda_96$value)=="N")]
SD_N_lambda_96 = SD_report_lambda_96$sd[which(names(SD_report_lambda_96$value)=="N")]


plot(x=c(1980:2020),y=N_est_TMB_het[22:62],ylim=c(0,800000),xlab="Year",ylab="Abundance estimate")
lines(x=c(1980:2020),y=N_est_TMB_lambda_96[22:62])
lines(x=c(1980:2020),y=N_est_TMB_lambda_98[22:62])
lines(x=c(1980:2020),y=N_est_TMB_lambda_102[22:62])
lines(x=c(1980:2020),y=N_est_TMB_lambda_104[22:62])

```
This exercise illustrates several phenomenon.  First, abundance estimates intersect around 2004, but are quite different by the end of the time series.  This is one phenomenon with CKMR estimation: precision and accuracy of estimates tend to be better towards to beginning of time series (in the "meat" of observed birth dates).  Second, the log pseudo-likelihood values are fairly similar for the five trend ($\lambda$) values, with $L=$ `r Report_lambda_96$logl`, `r Report_lambda_98$logl`, `r Report_het$logl`, `r Report_lambda_102$logl`, and `r Report_lambda_104$logl`for $\lambda = 0.96,0.98,1.0,1.02, \text{ and} 1.04$, respectively.  There is slightly more evidence for stable, slightly decreasing, or slightly increasing populations than there is for the large decline or large increase scenarios   - but we would certainly want a lot more kin pairs for reliable trend estimation.


### Alternative PLOD thresholds

Let's take a look at results if we were to use different PLOD thresholds for HSP/GGPs.  In these cases we'll still account for false negative probabilities, which will increase if we lower the PLOD threshold, or decrease if we increase the PLOD threshold.  However, there is some senstivity to this choice, and it's something to be aware of for CKMR studies with a low number of HSPs (we would expect this not to be much of an issue with higher sample sizes).  In particular, we'll look at results for HSP thresholds of 30 and 50 (our base model uses 40).





```{r,run_plod,tidy='styler',cache=T,include=FALSE}
library(TMB)

# PLOD threshold = 30
p_plod = 1-pnorm(30,HSP_PLOD_info$HSPmean,sd_est)
matches_PHS = CKMR_certain_age$matches_PHS[which(CKMR_certain_age$matches_PHS$PLOD>30),]
matches_MHS = CKMR_certain_age$matches_MHS[which(CKMR_certain_age$matches_MHS$PLOD>30),]

n_match_HSGGP_sibidibjmij=0*n_match_HSGGP_sibidibjmij

for(imatch in 1:nrow(matches_PHS)){
  if(BY[matches_PHS[imatch,"i"]]<=BY[matches_PHS[imatch,"j"]])
    n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$i[imatch]]=="M")+1,BY[matches_PHS$i[imatch]],DY[matches_PHS$i[imatch]],BY[matches_PHS$j[imatch]],1]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$i[imatch]]=="M")+1,BY[matches_PHS$i[imatch]],DY[matches_PHS$i[imatch]],BY[matches_PHS$j[imatch]],1]+1
  else
    n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$j[imatch]]=="M")+1,BY[matches_PHS$j[imatch]],DY[matches_PHS$j[imatch]],BY[matches_PHS$i[imatch]],1]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$j[imatch]]=="M")+1,BY[matches_PHS$j[imatch]],DY[matches_PHS$j[imatch]],BY[matches_PHS$i[imatch]],1]+1}

for(imatch in 1:nrow(matches_MHS)){
  if(BY[matches_MHS[imatch,"i"]]<=BY[matches_MHS[imatch,"j"]])
    n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$i[imatch]]=="M")+1,BY[matches_MHS$i[imatch]],DY[matches_MHS$i[imatch]],BY[matches_MHS$j[imatch]],2]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$i[imatch]]=="M")+1,BY[matches_MHS$i[imatch]],DY[matches_MHS$i[imatch]],BY[matches_MHS$j[imatch]],2]+1
  else
    n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$j[imatch]]=="M")+1,BY[matches_MHS$j[imatch]],DY[matches_MHS$j[imatch]],BY[matches_MHS$i[imatch]],2]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$j[imatch]]=="M")+1,BY[matches_MHS$j[imatch]],DY[matches_MHS$j[imatch]],BY[matches_MHS$i[imatch]],2]+1}


Data =   Data=list("n_yrs"=n_yrs,"n_yrs_data"=n_yrs_data,"n_seals"=n_seals,"n_ages"=n_ages,
            "Male_mat"=Male_mat,"Fem_fec"=Fem_fec,"A"=A,"n_match_HSGGP_sibidibjmij"=n_match_HSGGP_sibidibjmij,
            "n_comp_HSGGP_sibidibj"=n_comp_HSGGP_sibidibj,
            "n_match_MPO_bidibj"=n_match_MPO_bidibj,"n_comp_MPO_bidibj"=n_comp_MPO_bidibj,
            "n_match_PPO_bidibj"=n_match_PPO_bidibj,"n_comp_PPO_bidibj"=n_comp_PPO_bidibj,
            mu_log_eta1=log(0.055),mu_log_eta2=log(2.8),mu_log_eta3=log(0.076),
            sd_log_eta1=0.07*abs(log(0.055)),sd_log_eta2=0.2*abs(log(2.8)),sd_log_eta3=abs(0.08*log(0.076)),
            lambda_expect=1.0,min_repro_fem =3,min_repro_male=5,p_plod=p_plod)  #SD log multipliers set to achieve approx CV of 0.2 on real scale

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_30=Obj$report()
SD_report_30=sdreport(Obj)
N_est_TMB_30 = SD_report_30$value[which(names(SD_report$value)=="N")]
SD_N_30 = SD_report_30$sd[which(names(SD_report_30$value)=="N")]



# PLOD threshold = 50
p_plod = 1-pnorm(50,HSP_PLOD_info$HSPmean,sd_est)
matches_PHS = CKMR_certain_age$matches_PHS[which(CKMR_certain_age$matches_PHS$PLOD>50),]
matches_MHS = CKMR_certain_age$matches_MHS[which(CKMR_certain_age$matches_MHS$PLOD>50),]

n_match_HSGGP_sibidibjmij=0*n_match_HSGGP_sibidibjmij

for(imatch in 1:nrow(matches_PHS)){
  if(BY[matches_PHS[imatch,"i"]]<=BY[matches_PHS[imatch,"j"]])
    n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$i[imatch]]=="M")+1,BY[matches_PHS$i[imatch]],DY[matches_PHS$i[imatch]],BY[matches_PHS$j[imatch]],1]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$i[imatch]]=="M")+1,BY[matches_PHS$i[imatch]],DY[matches_PHS$i[imatch]],BY[matches_PHS$j[imatch]],1]+1
  else
    n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$j[imatch]]=="M")+1,BY[matches_PHS$j[imatch]],DY[matches_PHS$j[imatch]],BY[matches_PHS$i[imatch]],1]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_PHS$j[imatch]]=="M")+1,BY[matches_PHS$j[imatch]],DY[matches_PHS$j[imatch]],BY[matches_PHS$i[imatch]],1]+1}

for(imatch in 1:nrow(matches_MHS)){
  if(BY[matches_MHS[imatch,"i"]]<=BY[matches_MHS[imatch,"j"]])
    n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$i[imatch]]=="M")+1,BY[matches_MHS$i[imatch]],DY[matches_MHS$i[imatch]],BY[matches_MHS$j[imatch]],2]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$i[imatch]]=="M")+1,BY[matches_MHS$i[imatch]],DY[matches_MHS$i[imatch]],BY[matches_MHS$j[imatch]],2]+1
  else
    n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$j[imatch]]=="M")+1,BY[matches_MHS$j[imatch]],DY[matches_MHS$j[imatch]],BY[matches_MHS$i[imatch]],2]=
      n_match_HSGGP_sibidibjmij[(Sex[matches_MHS$j[imatch]]=="M")+1,BY[matches_MHS$j[imatch]],DY[matches_MHS$j[imatch]],BY[matches_MHS$i[imatch]],2]+1}


Data =   Data=list("n_yrs"=n_yrs,"n_yrs_data"=n_yrs_data,"n_seals"=n_seals,"n_ages"=n_ages,
            "Male_mat"=Male_mat,"Fem_fec"=Fem_fec,"A"=A,"n_match_HSGGP_sibidibjmij"=n_match_HSGGP_sibidibjmij,
            "n_comp_HSGGP_sibidibj"=n_comp_HSGGP_sibidibj,
            "n_match_MPO_bidibj"=n_match_MPO_bidibj,"n_comp_MPO_bidibj"=n_comp_MPO_bidibj,
            "n_match_PPO_bidibj"=n_match_PPO_bidibj,"n_comp_PPO_bidibj"=n_comp_PPO_bidibj,
            mu_log_eta1=log(0.055),mu_log_eta2=log(2.8),mu_log_eta3=log(0.076),
            sd_log_eta1=0.07*abs(log(0.055)),sd_log_eta2=0.2*abs(log(2.8)),sd_log_eta3=abs(0.08*log(0.076)),
            lambda_expect=1.0,min_repro_fem =3,min_repro_male=5,p_plod=p_plod)  #SD log multipliers set to achieve approx CV of 0.2 on real scale

Obj <- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL="certain_ages_GGP_plod_het")

#Minimize negative log likelihood and time it
Start_time = Sys.time()
Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr)
End_time = Sys.time()

Report_50=Obj$report()
SD_report_50=sdreport(Obj)
N_est_TMB_50 = SD_report_50$value[which(names(SD_report_50$value)=="N")]
SD_N_50 = SD_report_50$sd[which(names(SD_report_50$value)=="N")]

```

Looking at estimates from different sensitivity runs, we see that abundance estimates are fairly sensitive to the PLOD cutoff value,
with a 30 cutoff resulting in $\hat{N}=$ `r N_est_TMB_30[1]`; a 40 cutoff resulting in $\hat{N}=$ `r N_est_TMB_het[1]`, and a 50 cutoff resulting in $\hat{N}=$ `r N_est_TMB_50[1]`.  As more harvest data are collected, presumably resulting in an increased number of kin pairs, we hope that
this source of structural uncertainty will diminish.  


Let's take a look at a summary of estimated abundance from the combination of sensitivity runs we have attempted so far.  For the increasing and decreasing population
scenarios, we'll use average abundance from 1990-2020.

```{r,N_table,tidy='styler',cache=T}
N_df = data.frame(matrix(0,8,5))
colnames(N_df) = c("lambda","PLOD_cutoff","male_het","N_hat","CV")
N_df$lambda = c(1,1,0.96,0.98,1.02,1.04,1,1)
N_df$PLOD_cutoff = c(40,40,40,40,40,40,30,50)
N_df$male_het = c("no","yes","yes","yes","yes","yes","yes","yes")
N_df$N_hat = c(N_est_TMB[1],Report_het$N[1],mean(Report_lambda_96$N[32:62]),mean(Report_lambda_98$N[32:62]),mean(Report_lambda_102$N[32:62]),mean(Report_lambda_104$N[32:62]),Report_30$N[1],Report_50$N[1])
N_df$CV = c(SD_report$sd[1]/N_est_TMB[1],SD_N_het[1]/Report_het$N[1],mean(SD_N_lambda_96[32:62]/Report_lambda_96$N[32:62]),mean(SD_N_lambda_98[32:62]/Report_lambda_98$N[32:62]),mean(SD_N_lambda_inc102[32:62]/Report_lambda_102$N[32:62]),mean(SD_N_lambda_104[32:62]/Report_lambda_104$N[32:62]),SD_N_30[1]/Report_30$N[1],SD_N_50[1]/Report_50$N[1])
print(N_df)
```

### Survival

Let's take a look at the updated survival curve (prior vs. ``posterior") from our base model.

```{r,plot_surv,tidy='styler',cache=T}

  Plot_df = data.frame("Type"=rep(c("Prior","CKMR"),each=40),
                      "Value"=c(Survival$bearded,Report_het$S_a),
                      "Age"= rep(c(0:39),2))
  library(ggplot2)
  ggplot(Plot_df)+geom_line(aes(x=Age,y=Value,colour=Type,linetype=Type),size=1.1)+theme(text=element_text(size=16))
  
  png("bearded_surv_prior_posterior.png")
    ggplot(Plot_df)+geom_line(aes(x=Age,y=Value,colour=Type,linetype=Type),size=1.1)+theme(text=element_text(size=16))
  dev.off()
```

### Aging error

We did not elect tackle aging error, instead electing to assume that ages were known with certainty.  Including uncertainty in ages is 
certainly possible in CKMR estimation [@BravingtonEtAl2016], and would serve to increase uncertainty in resulting estimates.  However, it is 
difficult to summarize uncertainty in ages, partly because of the way teeth were analyzed.  The ages we used were primarily from tooth cementum annuli, and most of these were read by a single reader who assigned a ``most likely" age, as well as a range of ages that were plausible.  However, these ranges were not always accurate, as we had several kin pairs that indicated aging error magnitudes greater than assigned by the reader.  Ideally, aging error could be estimated using a separate experiment where multiple tag readers assess the same tooth [@Richards1992], and then incorporated directly into CKMR estimation.

### Comparison with aerial survey estimates

NOAA's Alaska Fisheries Science Center, together with Russian partners, conducted spring aerial surveys over the Bering Sea in 2012 and 2013, and over the Chukchi Sea in 2016.  Data from these surveys have been analyzed using spatio-temporal statistical models, which produced 
abundance estimates.  Although as-yet unpublished, bearded seal estimates were 147,000 for the Chukchi Sea; 185,000 for the Russian Bering in 2012; 144,000 for the Russian Bering in 2013; 271,000 for the U.S. Bering in 2012, and 251,000 for the U.S. Bering in 2013.  The Chukchi Sea surveys were conducted into late May, so it may not be quite as simple as adding the Chukchi and Bering estimates together (i.e., Chukchi Sea estimates likely includes seals that wintered in the Bering Sea and migrated northward while surveys were being conducted); however, a combined aerial survey estimate around 500,000 seems reasonable.  This is considerably higher than we estimated with CKMR, although the model with male heterogeneity in reproductive success comes close.  However, we are in some sense only estimating the population of seals that are exposed to Alaska Native subsistence hunters [@ConnEtAl2020], so there is good reason to suspect that the population we are estimating with CKMR is somewhat smaller than the entire Beringia DPS.  However, it may be the most relevant population estimate for population management purposes.  


## References
